using ALAN.Shared.Models;
using ALAN.Shared.Services.Memory;
using Microsoft.Extensions.Logging;
using System.Collections.Concurrent;

namespace ALAN.Agent.Services;

/// <summary>
/// Manages code change proposals generated by the agent.
/// Ensures all code changes require human approval before implementation.
/// </summary>
public class CodeProposalService
{
    private readonly ConcurrentDictionary<string, CodeProposal> _proposals = new();
    private readonly ILongTermMemoryService _longTermMemory;
    private readonly ILogger<CodeProposalService> _logger;

    public CodeProposalService(
        ILongTermMemoryService longTermMemory,
        ILogger<CodeProposalService> logger)
    {
        _longTermMemory = longTermMemory;
        _logger = logger;
    }

    /// <summary>
    /// Create a new code change proposal
    /// </summary>
    public async Task<string> CreateProposalAsync(CodeProposal proposal, CancellationToken cancellationToken = default)
    {
        _proposals[proposal.Id] = proposal;
        _logger.LogInformation("Created code proposal {Id}: {Title}", proposal.Id, proposal.Title);

        // Store proposal in long-term memory
        var memory = new MemoryEntry
        {
            Type = MemoryType.CodeChange,
            Content = $"Proposed: {proposal.Title}\n{proposal.Description}\n\nReasoning: {proposal.Reasoning}",
            Summary = proposal.Title,
            Importance = 0.8,
            Tags = new List<string> { "code-proposal", "pending-approval" },
            Metadata = new Dictionary<string, string>
            {
                ["ProposalId"] = proposal.Id,
                ["Status"] = proposal.Status.ToString()
            }
        };

        await _longTermMemory.StoreMemoryAsync(memory, cancellationToken);

        return proposal.Id;
    }

    /// <summary>
    /// Get a proposal by ID
    /// </summary>
    public CodeProposal? GetProposal(string proposalId)
    {
        _proposals.TryGetValue(proposalId, out var proposal);
        return proposal;
    }

    /// <summary>
    /// Get all pending proposals
    /// </summary>
    public List<CodeProposal> GetPendingProposals()
    {
        return _proposals.Values
            .Where(p => p.Status == ProposalStatus.Pending)
            .OrderByDescending(p => p.Created)
            .ToList();
    }

    /// <summary>
    /// Get all proposals with a specific status
    /// </summary>
    public List<CodeProposal> GetProposalsByStatus(ProposalStatus status)
    {
        return _proposals.Values
            .Where(p => p.Status == status)
            .OrderByDescending(p => p.Created)
            .ToList();
    }

    /// <summary>
    /// Approve a code proposal
    /// </summary>
    public async Task<bool> ApproveProposalAsync(string proposalId, string approvedBy, CancellationToken cancellationToken = default)
    {
        if (!_proposals.TryGetValue(proposalId, out var proposal))
        {
            _logger.LogWarning("Proposal {Id} not found for approval", proposalId);
            return false;
        }

        if (proposal.Status != ProposalStatus.Pending)
        {
            _logger.LogWarning("Proposal {Id} is not pending (current status: {Status})", proposalId, proposal.Status);
            return false;
        }

        proposal.Status = ProposalStatus.Approved;
        proposal.ApprovedBy = approvedBy;
        proposal.ApprovedAt = DateTime.UtcNow;

        _logger.LogInformation("Proposal {Id} approved by {ApprovedBy}", proposalId, approvedBy);

        // Store approval in long-term memory
        var memory = new MemoryEntry
        {
            Type = MemoryType.CodeChange,
            Content = $"Approved: {proposal.Title}\nApproved by: {approvedBy}",
            Summary = $"Code proposal approved: {proposal.Title}",
            Importance = 0.9,
            Tags = new List<string> { "code-proposal", "approved" },
            Metadata = new Dictionary<string, string>
            {
                ["ProposalId"] = proposal.Id,
                ["Status"] = proposal.Status.ToString(),
                ["ApprovedBy"] = approvedBy
            }
        };

        await _longTermMemory.StoreMemoryAsync(memory, cancellationToken);

        return true;
    }

    /// <summary>
    /// Reject a code proposal
    /// </summary>
    public async Task<bool> RejectProposalAsync(string proposalId, string reason, CancellationToken cancellationToken = default)
    {
        if (!_proposals.TryGetValue(proposalId, out var proposal))
        {
            _logger.LogWarning("Proposal {Id} not found for rejection", proposalId);
            return false;
        }

        if (proposal.Status != ProposalStatus.Pending)
        {
            _logger.LogWarning("Proposal {Id} is not pending (current status: {Status})", proposalId, proposal.Status);
            return false;
        }

        proposal.Status = ProposalStatus.Rejected;
        proposal.RejectionReason = reason;

        _logger.LogInformation("Proposal {Id} rejected: {Reason}", proposalId, reason);

        // Store rejection in long-term memory
        var memory = new MemoryEntry
        {
            Type = MemoryType.Decision,
            Content = $"Rejected: {proposal.Title}\nReason: {reason}",
            Summary = $"Code proposal rejected: {proposal.Title}",
            Importance = 0.7,
            Tags = new List<string> { "code-proposal", "rejected" },
            Metadata = new Dictionary<string, string>
            {
                ["ProposalId"] = proposal.Id,
                ["Status"] = proposal.Status.ToString()
            }
        };

        await _longTermMemory.StoreMemoryAsync(memory, cancellationToken);

        return true;
    }

    /// <summary>
    /// Mark a proposal as implemented
    /// </summary>
    public async Task<bool> MarkAsImplementedAsync(string proposalId, string pullRequestUrl, CancellationToken cancellationToken = default)
    {
        if (!_proposals.TryGetValue(proposalId, out var proposal))
        {
            _logger.LogWarning("Proposal {Id} not found", proposalId);
            return false;
        }

        if (proposal.Status != ProposalStatus.Approved)
        {
            _logger.LogWarning("Proposal {Id} is not approved (current status: {Status})", proposalId, proposal.Status);
            return false;
        }

        proposal.Status = ProposalStatus.Implemented;
        proposal.PullRequestUrl = pullRequestUrl;

        _logger.LogInformation("Proposal {Id} marked as implemented: {PullRequestUrl}", proposalId, pullRequestUrl);

        // Store implementation in long-term memory
        var memory = new MemoryEntry
        {
            Type = MemoryType.Success,
            Content = $"Implemented: {proposal.Title}\nPR: {pullRequestUrl}",
            Summary = $"Code proposal implemented: {proposal.Title}",
            Importance = 0.9,
            Tags = new List<string> { "code-proposal", "implemented", "success" },
            Metadata = new Dictionary<string, string>
            {
                ["ProposalId"] = proposal.Id,
                ["Status"] = proposal.Status.ToString(),
                ["PullRequestUrl"] = pullRequestUrl
            }
        };

        await _longTermMemory.StoreMemoryAsync(memory, cancellationToken);

        return true;
    }

    /// <summary>
    /// Get proposal statistics
    /// </summary>
    public ProposalStatistics GetStatistics()
    {
        var proposals = _proposals.Values.ToList();
        return new ProposalStatistics
        {
            Total = proposals.Count,
            Pending = proposals.Count(p => p.Status == ProposalStatus.Pending),
            Approved = proposals.Count(p => p.Status == ProposalStatus.Approved),
            Rejected = proposals.Count(p => p.Status == ProposalStatus.Rejected),
            Implemented = proposals.Count(p => p.Status == ProposalStatus.Implemented),
            Failed = proposals.Count(p => p.Status == ProposalStatus.Failed)
        };
    }
}

public class ProposalStatistics
{
    public int Total { get; set; }
    public int Pending { get; set; }
    public int Approved { get; set; }
    public int Rejected { get; set; }
    public int Implemented { get; set; }
    public int Failed { get; set; }
}
